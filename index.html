<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tic Tac Toe: Human vs AI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Basic Reset and Layout */
    body {
      background: #f7f7f7;
      font-family: 'Segoe UI', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 0;
      margin: 0;
    }
    h1 {
      margin-top: 30px;
      margin-bottom: 10px;
      letter-spacing: 1px;
      color: #32325d;
      font-size: 2rem;
      text-align: center;
    }
    #game {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(3, 70px);
      grid-template-rows: repeat(3, 70px);
      gap: 10px;
      background: #363a57;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 24px 0 rgba(50,50,93,0.07);
      margin-bottom: 18px;
      user-select: none;
    }
    .cell {
      width: 70px;
      height: 70px;
      background: #fff;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.2rem;
      color: #2c3e50;
      cursor: pointer;
      transition: background .15s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.04);
    }
    .cell.winning {
      background: #ffe066;
      color: #d35400;
      /* Highlight the winning sequence */
    }
    .cell:active:enabled {
      background: #ececec;
    }
    .cell[disabled] {
      cursor: not-allowed;
      color: #b1b1b1;
    }
    #status {
      min-height: 28px;
      font-size: 1.15rem;
      color: #363636;
      margin-bottom: 10px;
      text-align: center;
    }
    #turn {
      margin-bottom: 6px;
      height: 24px;
      color: #2b3456;
      font-size: 1.05rem;
      text-align: center;
      font-weight: 500;
    }
    #restart {
      padding: 8px 24px;
      font-size: 1rem;
      background: #4846fb;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background .13s;
      box-shadow: 0 2px 8px rgba(72,70,251,0.08);
    }
    #restart:hover, #restart:active {
      background: #2b296a;
    }
    @media (max-width: 500px) {
      #board {
        grid-template-columns: repeat(3, 23vw);
        grid-template-rows: repeat(3, 23vw);
        gap: 4vw;
        padding: 4vw;
      }
      .cell {
        width: 23vw;
        height: 23vw;
        font-size: 8vw;
      }
    }
  </style>
</head>
<body>

  <h1>Tic Tac Toe</h1>
  <div id="game">
    <div id="turn"></div>
    <div id="board"></div>
    <div id="status"></div>
    <button id="restart">Restart Game</button>
  </div>

  <script>
  // -- Constants and Utility (Encapsulated in IIFE) --
  (() => {
    // Symbols
    const HUMAN = 'X';
    const AI = 'O';

    // State Management
    function createInitialState() {
      return {
        board: Array(9).fill(null),
        isGameOver: false,
        winner: null,          // 'X', 'O', or 'draw'
        winningCombo: [],      // Indices of winning line
        currentTurn: HUMAN     // Always 'X' at start
      }
    }

    // All possible winning combinations (triplets of indices)
    const WIN_COMBOS = [
      [0,1,2],[3,4,5],[6,7,8], // Rows
      [0,3,6],[1,4,7],[2,5,8], // Cols
      [0,4,8],[2,4,6]          // Diags
    ];

    // Game Logic
    const GameLogic = (() => {
      // Check for winner or draw, returns {winner, combo} or null
      function checkGameOver(board) {
        for (let combo of WIN_COMBOS) {
          const [a,b,c] = combo;
          if (
            board[a] &&
            board[a] === board[b] &&
            board[a] === board[c]
          ) {
            return { winner: board[a], combo };
          }
        }
        if (!board.includes(null)) {
          return { winner: 'draw', combo: [] };
        }
        return null; // Not over yet
      }

      // Validate move: cell in bounds and empty
      function isValidMove(board, idx) {
        return idx >= 0 && idx < 9 && !board[idx];
      }

      // Minimax algorithm implementation for "O" (AI)
      function minimax(board, isMaximizing) {
        // Terminal state
        const check = checkGameOver(board);
        if (check) {
          if (check.winner === AI) return { score: 1 };
          else if (check.winner === HUMAN) return { score: -1 };
          else return { score: 0 };
        }
        // Minimax recursion
        if (isMaximizing) {
          let bestScore = -Infinity, move = null;
          for (let i = 0; i < 9; ++i) {
            if (!board[i]) {
              board[i] = AI;
              let score = minimax(board, false).score;
              board[i] = null;
              if (score > bestScore) {
                bestScore = score;
                move = i;
              }
            }
          }
          return { score: bestScore, move };
        } else {
          let bestScore = Infinity, move = null;
          for (let i = 0; i < 9; ++i) {
            if (!board[i]) {
              board[i] = HUMAN;
              let score = minimax(board, true).score;
              board[i] = null;
              if (score < bestScore) {
                bestScore = score;
                move = i;
              }
            }
          }
          return { score: bestScore, move };
        }
      }

      // Get the AI's best move using minimax
      function getAIMove(board) {
        let { move } = minimax([...board], true);
        return move; // index of best move
      }

      // Public Methods
      return {
        checkGameOver,
        isValidMove,
        getAIMove
      }
    })();

    // -- UI Rendering and DOM Logic --
    const GameUI = (() => {
      const cells = [];
      const boardEl = document.getElementById('board');
      const statusEl = document.getElementById('status');
      const turnEl = document.getElementById('turn');
      const restartBtn = document.getElementById('restart');

      let currentState = createInitialState();

      // Render the 3x3 grid
      function initBoard() {
        boardEl.innerHTML = "";
        cells.length = 0;
        for (let i = 0; i < 9; ++i) {
          const btn = document.createElement('button');
          btn.classList.add('cell');
          btn.setAttribute('data-idx', i);
          btn.addEventListener('click', handleCellClick);
          btn.setAttribute('aria-label', `Cell ${i+1}`);
          cells.push(btn);
          boardEl.appendChild(btn);
        }
      }

      // Render board from state
      function renderBoard(state) {
        for (let i = 0; i < 9; ++i) {
          cells[i].textContent = state.board[i] || '';
          cells[i].disabled = state.isGameOver || state.board[i] !== null;
          cells[i].classList.remove('winning');
        }
        // Highlight winning cells if any
        if (state.winningCombo.length > 0) {
          state.winningCombo.forEach(idx => {
            cells[idx].classList.add('winning');
          });
        }
      }

      // Update turn display
      function renderTurn(state) {
        if (state.isGameOver) {
          turnEl.textContent = '';
        } else if (state.currentTurn === HUMAN) {
          turnEl.textContent = 'Your turn ("X")';
        } else {
          turnEl.textContent = 'AI\'s turn ("O")';
        }
      }

      // Update status text
      function renderStatus(state) {
        if (!state.isGameOver) {
          statusEl.textContent = '';
        } else if (state.winner === HUMAN) {
          statusEl.textContent = 'You win! ðŸŽ‰';
        } else if (state.winner === AI) {
          statusEl.textContent = 'AI wins! ðŸ¤–';
        } else {
          statusEl.textContent = 'It\'s a draw!';
        }
      }

      // Main render function
      function render(state) {
        renderBoard(state);
        renderTurn(state);
        renderStatus(state);
      }

      // Handle user click
      function handleCellClick(e) {
        const idx = Number(e.target.getAttribute('data-idx'));
        if (
          currentState.isGameOver ||
          currentState.currentTurn !== HUMAN ||
          !GameLogic.isValidMove(currentState.board, idx)
        ) return;

        // Human move
        doMove(idx, HUMAN);
      }

      // Make a move
      function doMove(idx, player) {
        if (!GameLogic.isValidMove(currentState.board, idx)) return;
        currentState.board = currentState.board.slice();
        currentState.board[idx] = player;

        // Check for end of game
        const outcome = GameLogic.checkGameOver(currentState.board);
        if (outcome) {
          currentState.isGameOver = true;
          currentState.winner = (outcome.winner === 'draw') ? 'draw' : outcome.winner;
          currentState.winningCombo = outcome.combo;
          currentState.currentTurn = null;
        } else {
          // Continue
          currentState.currentTurn = (player === HUMAN) ? AI : HUMAN;
        }
        render(currentState);

        if (!currentState.isGameOver && currentState.currentTurn === AI) {
          setTimeout(aiMove, 360); // brief delay for realism
        }
      }

      // AI makes its move (with Minimax)
      function aiMove() {
        // AI must play optimally (Minimax)
        const idx = GameLogic.getAIMove(currentState.board);
        if (idx != null) {
          doMove(idx, AI);
        }
      }

      // Restart/reset the game
      function restart() {
        currentState = createInitialState();
        render(currentState);
      }

      // Public API
      return {
        init() {
          initBoard();
          render(currentState);
          restartBtn.addEventListener('click', restart);
        }
      }
    })();

    // -- Initialize the game on load --
    window.addEventListener('DOMContentLoaded', GameUI.init);

  })(); // End IIFE
  </script>
  
</body>
</html>S\
